---
typora-root-url: images
typora-copy-images-to: images
---

# JVM

## 组成部分

- 类加载器
- 运行时数据区
  - 方法区
  - Java栈
  - 本地方法栈
  - 堆
  - 程序计数器
- 执行引擎
- 本地接口
- 本地库

## 内存组成部分/划分

- 程序计数器：线程私有。当前线程执行字节码的行号指示器
  - 如果线程正在执行一个Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址。
  - 如果是执行的是Native方法，这个计数器值为空。
  - 该内存区域是唯一在Java虚拟机规范中没有任何OutOfMemoryError情况的区域。
- 虚拟机栈:Java线程私有，虚拟机栈描述的是Java方法执行的内存模型
  - 每个方法执行的时候，会创建一个栈帧用于存储局部变量、操作数、动态链接以及方法出口等信息。
  - 每个方法调用都意味着一个栈帧在虚拟机栈中的入栈到出栈。
- 本地方法栈:与Java虚拟机栈的作用类似，区别在于该区域为JVM提供使用Native方法服务。
- 堆内存：线程共享 
  - 采用**分代回收算法**，
  - 根据Java虚拟机规范规定，Java Heap可以处于物理不连续的内存空间中，只需要逻辑连续即可。
- 方法区 : 线程共享。
  - **Java虚拟机规范**只定义方法区的概念以及作用，但并不规定实现方式。
  - jdk7的实现方式--永久代。
  - 加载的类信息、常亮、静态变量、即时编译器编译后的代码等数据。
  - 运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。
- MetaSpace
  - JDK8替代Perm Space.  
  - 字符串常量存放到堆内存中。

## Direct Memory

- 直接内存(Direct Memory)，并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中农定义的内存区域。在 JDK1.4 中新加入了 NIO(New Input/Output) 类，引入了一种基于通道(Channel)与缓冲区（Buffer）的 I/O 方式，它可以使用 native 函数库直接分配堆外内存，通过一个存储在 Java 堆中的**DirectByteBuffer 对象**作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。

- 本机直接内存的分配不会受到 Java 堆大小的限制，受到本机总内存大小限制。
  配置虚拟机参数时，不要忽略直接内存，防止出现 OutOfMemoryError 异常。
- 直接内存（堆外内存）与堆内存比较？
  - 直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显。
  - 直接内存 IO 读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显。

## 废弃永久代的原因

- 永久代内存经常不够用或者发生内存泄漏。
  - 字符串存在永久代中，容易出现性能问题以及内存溢出。
  - 类以及方法的信息等比较难确定大小，造成无法预估永久代的大小。太小容易永久代溢出，太大容易老年代溢出。
- 永久代会给GC带来复杂度以及回收效率。
- Oracle可能将会把HotSpot与JRockit合二为一。
  - JRockit没有永久代，不需要配置它。

## 内存堆和栈区别

- 栈内存用来存储基本类型的变量和对象的引用变量；堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。
- 栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存；堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。
- 如果栈内存没有可用的空间存储方法调用和局部变量，JVM 会抛出 `java.lang.StackOverFlowError` 错误；如果是堆内存没有可用的空间存储生成的对象，JVM 会抛出 `java.lang.OutOfMemoryError` 错误。
- 栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。`-Xss` 选项设置栈内存的大小，`-Xms` 选项可以设置堆的开始时的大小。

> JVM 中堆和栈属于不同的内存区域，**使用目的也不同**。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。

## 对象创建过程

![](/03.png)



Java 中对象的创建就是在堆上分配内存空间的过程，此处说的对象创建仅限于 new 关键字创建的普通 Java 对象，不包括数组对象的创建。

1）检测类是否被加载

当虚拟机遇到 `new` 指令时，首先先去检查这个指令的参数是否能在常量池中**定位到一个类的符号引用**，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，就执行类加载过程。

2）为对象分配内存

类加载完成以后，虚拟机就开始为对象分配内存，此时所需内存的大小就已经确定了。只需要在堆上分配所需要的内存即可。

具体的分配内存有两种情况：第一种情况是内存空间绝对规整，第二种情况是内存空间是不连续的。

- 对于内存绝对规整的情况相对简单一些，虚拟机只需要在被占用的内存和可用空间之间移动指针即可，这种方式被称为“**指针碰撞**”。
- 对于内存不规整的情况稍微复杂一点，这时候虚拟机需要维护一个列表，来记录哪些内存是可用的。分配内存的时候需要找到一个可用的内存空间，然后在列表上记录下已被分配，这种方式成为“**空闲列表**”。

多线程并发时会出现正在给对象 A 分配内存，还没来得及修改指针，对象 B 又用这个指针**分配内存**，这样就出现问题了。解决这种问题有两种方案：

- 第一种，是采用同步的办法，使用 CAS 来保证操作的原子性。
- 另一种，是每个线程分配内存都在自己的空间内进行，即是每个线程都在堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB），分配内存的时候再TLAB上分配，互不干扰。可以通过 `-XX:+/-UseTLAB` 参数决定。

3）为分配的内存空间初始化零值

对象的内存分配完成后，还需要将对象的内存空间都初始化为零值，这样能保证对象即使没有赋初值，也可以直接使用。

4）对对象进行其他设置

分配完内存空间，初始化零值之后，虚拟机还需要对对象进行其他必要的设置，设置的地方都在对象头中，包括这个对象所属的类，类的元数据信息，对象的 hashcode ，GC 分代年龄等信息。

5）执行 init 方法

执行完上面的步骤之后，在虚拟机里这个对象就算创建成功了，但是对于 Java 程序来说还需要执行 init 方法才算真正的创建完成，因为这个时候对象只是被初始化零值了，还没有真正的去根据程序中的代码分配初始值，调用了 init 方法之后，这个对象才真正能使用。

到此为止一个对象就产生了，这就是 new 关键字创建对象的过程。过程如下：

![](/07.png)



## 对象的内存分布

- 由以下三个部分组成
  - 对象头
    - 第一部分：标识信息，存储对象自身的运行时数据，如哈希码，GC分代年龄、锁状态标志以及线程持有的锁等。
    - 第二部分: 类型指针，即对象指向类元数据的指针。
    - 以上两个部分分别占用8个字节，因此每个对象的额外内存为16个字节。
  - 实例数据：数据
  - 对齐填充:  非必须数据，只是为了对齐。

## 对象访问方式

- 句柄定位

  - Java堆中一块内存作为句柄池，栈中的reference中存储的是**对象的句柄**地址，句柄中包含了对象实例数据与类型数据各自的**具体地址信息**。

  ![04](/04.png)

- 直接指针访问：reference存储**对象地址**

![05](/05.png)

- 两者区别
  - 句柄方式的优点; 对象移动(比如垃圾收集的时候)的时只需要修改句柄中的实例数据指针即可。而reference本身不需要修改。
  - 直接指针访问方式的优点：节省一次指针定位的时间开销，由于对象的访问比较频繁，可节省大量的时间开销。
  - 目前Sun HotSpot采用第二种。

## OOM排查

- 控制台查看错误信息
- JDK的jvisulvm 工具查看系统的堆栈日志
- 定位内存溢出的空间：堆、栈还是元空间
  - 堆溢出，是否创建超大的对象。
  - 栈溢出，创建1：大对象，2：死循环，3：递归。

## 不建议显式 声明 System.gc()

- 引发堆内存全扫描。  Full GC。
- 不立即执行Full GC。

## GC Roots对象

- 栈中引用的对象
- 方法区中的静态属性引用的对象
- 方法区中常量引用的对象。
- 本地方法栈中JNI中引用的对象。

### TLAB

- Thread Local Allocation Buffer
- 解决多线程竞争堆内存分配的问题，
- 两个重要的指针；1-记录空余的起止地址， 2-TLAB分配内存的结束地址

### CardTable

- **记录老年代对新生代引用的情况**。
- 解决减少老年代的全堆空间扫描，只将脏表中的对象作为GC roots

## OopMap

- 由于目前的主流 JVM 使用的都是准确式 GC（这个概念在第一篇中介绍过），所以当执行系统停顿下来之后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得到哪些地方存放着对象引用。在 HotSpot 的实现中，是使用一组成为 OopMap 的数据结构来达到这个目的，在类加载完成的时候，HotSpot 就把对象内什么偏移量上是什么类型的数据计算出来，在 JIT 编译过程中，也会在**特定的位置**(安全点)记录下栈里和寄存器里哪些位置是引用。这样 GC 在扫描时就就可以直接得知这些信息了。

- 通过OopMap的协助，HotSpot可以快速完成GC Roots枚举。

- 在 OopMap 的协助下，HotSpot 可以快速准确地地完成 GC Roots 枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说 OopMap 内容变化的指令非常多，如果为每一条指令都生成对应的 OopMap，那将会需要大量的额外空间，这样 GC 的空间成本将会变得很高。

  实际上 HotSpot 也的确没有为每条指令都生成 OopMap，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置被称为安全点（Safepoint），即程序执行时并非在所有的地方都能停顿下来开始 GC，只有在到达安全点时才能暂停。Safepoint 的选定既不能太少以至于让 GC 等待时间太长，也不能过于频繁以至于过分增大运行时的负荷
  
- JVM采用了OopMap这个数据结构记录了GC roots，GC的标记开始的时候，直接从OopMap就可以获得GC roots。OopMap记录了特定时刻栈上(内存)和寄存器(CPU)的哪些位置是引用，通过这些引用就可以找到堆中的对象，这些对象就是GC roots. 而不需要一个一个的去判断某个内存位置的值是不是引用。


## 安全点--SafePoint

### 概述

​	一些特定的位置，当线程运行到这些位置时候，线程的一些状态可以被确定，比如记录**OopMap**的状态，从而确定GC Root的信息，使JVM可以安全的进行一些操作，比如开始GC。

- OopMap 用于枚举GC Roots。记录栈上本地变量到堆上对象的引用关系。避免全栈扫描。
- RememberedSet 用于可达性分析。

### 特定位置主要有：

- 循环的末尾
- 方法返回前
- 调用方法的Call之后
- 抛出异常的位置

### 线程中止方式

- 主动式
  - JVM设置一个全局变量，线程去按照某种策略检查这个变量，一旦发现是SafePoint就主动挂起。
- 被动式
  - 发个信号，例如关机、Control+C、带来的问题时候不可控，发信号的时候无法感知线程出于什么状态。

### 安全区域

如果程序长时间不执行，比如线程调用的 sleep 方法，这时候程序无法响应 JVM 中断请求这时候线程无法到达安全点，显然 JVM 也不可能等待程序唤醒，这时候就需要安全区域了。

安全区域是指一段代码片中，引用关系不会发生变化，在这个区域任何地方 GC 都是安全的，安全区域可以看做是安全点的一个扩展。

- 线程执行到安全区域的代码时，首先标识自己进入了安全区域，这样 GC 时就不用管进入安全区域的线程了.
- 线程要**离开安全区域**时就检查 JVM 是否完成了 GC Roots 枚举（或者整个 GC 过程），如果完成就继续执行，如果没有完成就等待直到收到可以安全离开的信号。

## 引用类型

- 强引用
- 软引用
- 弱引用
- 虚引用

利用软引用和弱引用解决OOM问题。通过软引用实现Java对象的高速缓存。

## JVM垃圾回收算法

- 标记-清除算法
  - 效率以及造成不连续空间的问题
- 标记-整理算法
  - 效率问题
- 复制算法
  - 浪费一半空间。活得久的对象被频繁移动，效率低。
- 分代收集算法
  - 商业虚拟机主要采用的算法。根据对象存活周期的不同将内存划分为几块区域。不容的区域采用**不同的收集算法**。


## G1

- 主要步骤
  - 初始标记  #STW，触发young GC
  - 并发标记
  - 重新标记  #STW
  - 复制清除  #STW

## ZGC

- 可以回收数TB的堆上具有非常低的暂停时间。
- 设计目标
  - 支持TB级内存容量。
  - 暂停时间低(<10ms)
  - 对整个程序吞吐量的影响小于15%。
  - 扩展实现机制，比如支持多层堆以及压缩堆。

##  触发Full GC /Major GC 条件

- 在执行 Young GC 之前，JVM 会进行空间分配担保——如果老年代的连续空间小于新生代对象的总大小（或历次晋升的平均大小），则触发一次 Full GC 。
- 大对象直接进入老年代，从年轻代晋升上来的老对象，尝试在老年代分配内存时，但是老年代内存空间不够。
- 显式调用 `System#gc()` 方法时。

## 类加载器

- Bootstrap ClassLoader
- Extension ClassLoader
- System  ClassLoader

### 实现优先使用ClassLoader

- 实现共享，可避免重复加载。
- 隔离，达到安全性。

## 内存屏障

- 内存屏障，又称内存栅栏，是一组处理器指令，用于实现对内存操作的**顺序限制**。

##  内存模型



