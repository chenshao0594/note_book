# JVM

## 组成部分

- 类加载器
- 运行时数据区
  - 方法区
  - Java栈
  - 本地方法栈
  - 堆
  - 程序计数器
- 执行引擎
- 本地接口
- 本地库

## 内存区

- 程序计数器：线程私有。当前线程执行字节码的行号指示器
  - 如果线程正在执行一个Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址。
  - 如果是执行的是Native方法，这个计数器值为空。
  - 该内存区域是唯一在Java虚拟机规范中没有任何OutOfMemoryError情况的区域。
- 虚拟机栈:Java线程私有，虚拟机栈描述的是Java方法执行的内存模型
  - 每个方法执行的时候，会创建一个栈帧用于存储局部变量、操作数、动态链接以及方法出口等信息。
  - 每个方法调用都意味着一个栈帧在虚拟机栈中的入栈到出栈。
- 本地方法栈:与Java虚拟机栈的作用类似，区别在于该区域为JVM提供使用Native方法服务。
- 堆内存：线程共享 
  - 采用**分代回收算法**，
  - 根据Java虚拟机规范规定，Java Heap可以处于物理不连续的内存空间中，只需要逻辑连续即可。
- 方法区 : 线程共享。
  - **Java虚拟机规范**只定义方法区的概念以及作用，但并不规定实现方式。
  - jdk7的实现方式--永久代。
  - 加载的类信息、常亮、静态变量、即时编译器编译后的代码等数据。
  - 运行时常量池：是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。
- MetaSpace
  - JDK8替代Perm Space.  
  - 字符串常量存放到堆内存中。

## Direct Memory

- 直接内存(Direct Memory)，并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中农定义的内存区域。在 JDK1.4 中新加入了 NIO(New Input/Output) 类，引入了一种基于通道(Channel)与缓冲区（Buffer）的 I/O 方式，它可以使用 native 函数库直接分配堆外内存，通过一个存储在 Java 堆中的**DirectByteBuffer 对象**作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。

- 本机直接内存的分配不会受到 Java 堆大小的限制，受到本机总内存大小限制。
  配置虚拟机参数时，不要忽略直接内存，防止出现 OutOfMemoryError 异常。
- 直接内存（堆外内存）与堆内存比较？
  - 直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显。
  - 直接内存 IO 读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显。

## 废弃永久代的原因

- 永久代内存经常不够用或者发生内存泄漏。
  - 字符串存在永久代中，容易出现性能问题以及内存溢出。
  - 类以及方法的信息等比较难确定大小，造成无法预估永久代的大小。太小容易永久代溢出，太大容易老年代溢出。
- 永久代会给GC带来复杂度以及回收效率。
- Oracle可能将会把HotSpot与JRockit合二为一。
  - JRockit没有永久代，不需要配置它。

## 内存堆和栈区别

- 栈内存用来存储基本类型的变量和对象的引用变量；堆内存用来存储Java中的对象，无论是成员变量，局部变量，还是类变量，它们指向的对象都存储在堆内存中。
- 栈内存归属于单个线程，每个线程都会有一个栈内存，其存储的变量只能在其所属线程中可见，即栈内存可以理解成线程的私有内存；堆内存中的对象对所有线程可见。堆内存中的对象可以被所有线程访问。
- 如果栈内存没有可用的空间存储方法调用和局部变量，JVM 会抛出 `java.lang.StackOverFlowError` 错误；如果是堆内存没有可用的空间存储生成的对象，JVM 会抛出 `java.lang.OutOfMemoryError` 错误。
- 栈的内存要远远小于堆内存，如果你使用递归的话，那么你的栈很快就会充满。`-Xss` 选项设置栈内存的大小，`-Xms` 选项可以设置堆的开始时的大小。

> JVM 中堆和栈属于不同的内存区域，**使用目的也不同**。栈常用于保存方法帧和局部变量，而对象总是在堆上分配。栈通常都比堆小，也不会在多个线程之间共享，而堆被整个 JVM 的所有线程共享。

## 对象创建过程

